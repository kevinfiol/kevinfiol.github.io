<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="ie=edge" http-equiv=X-UA-Compatible><meta content="kevin f.'s personal site" name=description><link rel="shortcut icon" href=https://kevinfiol.com/img/favicon.png type=image/x-icon><link href=https://kevinfiol.com/css/main.css rel=stylesheet><link href=https://kevinfiol.com/atom.xml rel=alternate title=feed type=application/atom+xml><title>
            
                Bullet Pools with Timers in HaxeFlixel
            
        </title><body><div class=dark-mode-container><input id=darkSwitch type=checkbox><label class=dark-mode-btn for=darkSwitch>ðŸŒ’</label></div><main class="main-content max-width-3 mx-auto"><div><div class="controls p1"><a href=https://github.com/kevinfiol/kevinfiol.com/edit/master/content/blog/2019-05-18-bullet-pools-with-timers-in-haxeflixel.md>edit</a></div><header><nav><p class=h3><a href=/>kevin f.</a></nav></header><small class="h5 p0 m0 light-subdue"> May 18, 2019 </small><aside></aside><article class=page-content><h1 id=bullet-pools-with-timers-in-haxeflixel><a aria-label="Anchor link for: bullet-pools-with-timers-in-haxeflixel" class=zola-anchor href=#bullet-pools-with-timers-in-haxeflixel>#</a>Bullet Pools with Timers in HaxeFlixel</h1><p>One of the more useful features of the flixel library is the inclusion of the <a href=http://api.haxeflixel.com/flixel/group/FlxTypedGroup.html>FlxTypedGroup</a> class, which makes it easier to organize, update, and render multiple instances of an FlxBasic object. A few getter methods provide useful information such as the length of the group, or an array of every member in an instantiated group.<p>A practical application of FlxTypedGroup can be found in the <a href=https://github.com/HaxeFlixel/flixel-demos/tree/master/Arcade/FlxTeroids/source>'Asteroids' demo</a> available via the HaxeFlixel repository. FlxTypedGroup's <code>recycle</code> method allows us to resuse bullet objects without having to destroy, recreate, and reallocate memory each time. Instead, bullets can be respawned from the queue after the pool has been "expended."<blockquote><p>Note: In the demo example available in the HaxeFlixel repository, the properties of each bullet are initialized on the fly within <code>PlayState.hx</code>. For my example, I have created a separate <code>Bullet</code> class for the sake of convenience.</blockquote><p>In the current PlayState, we can create and initialize a pool called <code>bullets</code> which we will populate with bullet objects from which we can spawn bullets as we please. In this case, I will create a pool with a maximum size of 3.<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span style=color:#b48ead>class </span><span style=color:#ebcb8b>PlayState </span><span style=color:#b48ead>extends </span><span style=color:#eff1f5>FlxState
</span><span style=color:#eff1f5>{
</span><span style=color:#eff1f5>	</span><span style=color:#b48ead>public static var </span><span style=color:#bf616a>bullets</span><span>:</span><span style=color:#eff1f5>FlxTypedGroup&LTBullet>;
</span><span style=color:#eff1f5>	</span><span style=color:#b48ead>override public function </span><span style=color:#8fa1b3>create</span><span>():</span><span style=color:#ebcb8b>Void
</span><span style=color:#eff1f5>	{
</span><span style=color:#eff1f5>		</span><span style=color:#b48ead>var </span><span style=color:#bf616a>poolSize</span><span>:</span><span style=color:#ebcb8b>Int </span><span>= </span><span style=color:#d08770>3</span><span style=color:#eff1f5>;
</span><span style=color:#eff1f5>		</span><span style=color:#b48ead>var </span><span style=color:#bf616a>bullet</span><span>:</span><span style=color:#eff1f5>Bullet;
</span><span style=color:#eff1f5>		</span><span style=color:#bf616a>bullets </span><span>= new </span><span style=color:#eff1f5>FlxTypedGroup&LTBullet>(</span><span style=color:#bf616a>poolSize</span><span style=color:#eff1f5>);
</span><span style=color:#eff1f5>	}
</span><span style=color:#eff1f5>}
</span></code></pre><p>From here, we can write a simple loop to create new bullet objects and simply add them to the existing group.<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span>...
</span><span style=color:#b48ead>override public function </span><span style=color:#8fa1b3>create</span><span>():</span><span style=color:#ebcb8b>Void
</span><span>{
</span><span>	</span><span style=color:#b48ead>var </span><span style=color:#bf616a>poolSize</span><span>:</span><span style=color:#ebcb8b>Int </span><span>= </span><span style=color:#d08770>3</span><span>;
</span><span>	</span><span style=color:#b48ead>var </span><span style=color:#bf616a>bullet</span><span>:Bullet;
</span><span>	</span><span style=color:#bf616a>bullets </span><span>= new FlxTypedGroup&LTBullet>(</span><span style=color:#bf616a>poolSize</span><span>);
</span><span>	</span><span style=color:#b48ead>for </span><span>(</span><span style=color:#bf616a>i </span><span style=color:#b48ead>in </span><span style=color:#d08770>0</span><span>...</span><span style=color:#bf616a>poolSize</span><span>) {
</span><span>		</span><span style=color:#bf616a>bullet </span><span>= new Bullet();
</span><span>		</span><span style=color:#bf616a>bullets</span><span>.</span><span style=color:#8fa1b3>add</span><span>(</span><span style=color:#bf616a>bullet</span><span>);
</span><span>	}
</span><span>}
</span><span>...
</span></code></pre><p>Within our Player class, we can then just reference the main PlayState's <code>bullets</code> pool to recycle <code>bullet</code> objects.<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span style=color:#b48ead>if</span><span> (FlxG.</span><span style=color:#bf616a>keys</span><span>.</span><span style=color:#bf616a>justPressed</span><span>.</span><span style=color:#bf616a>Z</span><span>) {
</span><span>	</span><span style=color:#b48ead>var </span><span style=color:#bf616a>bullet</span><span>:Bullet = PlayState.</span><span style=color:#bf616a>bullets</span><span>.</span><span style=color:#8fa1b3>recycle</span><span>();
</span><span>	</span><span style=color:#65737e>// YOUR BULLET VELOCITY CODE GOES HERE
</span><span>}
</span></code></pre><p>After this, we just add our standard logic that handles bullet velocity, acceleration, or how, when, and where your Sprite class may spawn bullet objects. As seen in the example below, only 3 bullets may be on the screen at one time, with the earliest spawned bullet being replaced.</p><img alt="asteroids animation" loading=lazy src=/img/blog/haxeflixel-bullet-timers/1.gif><p>Building on the example of the original Asteroids arcade game, we can give each bullet a limited lifetime, meaning if the bullet does not collide with another asteroid or enemy sprite, it should cease to exist after a certain period of time. Otherwise, it would continue travelling endlessly.<p>I was able to do this using HaxeFlixel's <a href=http://api.haxeflixel.com/flixel/util/FlxTimer.html>FlxTimer</a> class, however, you may also use the standard <a href=http://api.haxe.org/haxe/Timer.html>Timer</a> class included in the Haxe Toolkit.<p>Within my <code>Bullet.hx</code> class, I declare <code>timer</code> and initialize it as an FlxTimer object in the class constructor.<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span style=color:#b48ead>class </span><span style=color:#ebcb8b>Bullet </span><span style=color:#b48ead>extends </span><span style=color:#eff1f5>FlxSprite
</span><span style=color:#eff1f5>{
</span><span style=color:#eff1f5>	</span><span style=color:#b48ead>public var </span><span style=color:#bf616a>timer</span><span>:</span><span style=color:#eff1f5>FlxTimer;
</span><span style=color:#eff1f5>	</span><span style=color:#b48ead>public function new</span><span>(</span><span style=color:#bf616a>X</span><span>:</span><span style=color:#ebcb8b>Float </span><span>= </span><span style=color:#d08770>0</span><span style=color:#eff1f5>, </span><span style=color:#bf616a>Y</span><span>:</span><span style=color:#ebcb8b>Float </span><span>= </span><span style=color:#d08770>0</span><span>) 
</span><span style=color:#eff1f5>	{
</span><span style=color:#eff1f5>		</span><span style=color:#bf616a>super</span><span style=color:#eff1f5>(</span><span style=color:#bf616a>X</span><span style=color:#eff1f5>, </span><span style=color:#bf616a>Y</span><span style=color:#eff1f5>);
</span><span style=color:#eff1f5>		</span><span style=color:#bf616a>timer </span><span>= new </span><span style=color:#eff1f5>FlxTimer();
</span><span style=color:#eff1f5>		</span><span style=color:#65737e>//YOUR OBJECT PROPERTIES GO HERE
</span><span style=color:#eff1f5>	}
</span><span style=color:#eff1f5>	</span><span style=color:#b48ead>override public function </span><span style=color:#8fa1b3>update</span><span>(</span><span style=color:#bf616a>elapsed</span><span>:</span><span style=color:#ebcb8b>Float</span><span>):</span><span style=color:#ebcb8b>Void
</span><span style=color:#eff1f5>	{
</span><span style=color:#eff1f5>		</span><span>...
</span><span style=color:#eff1f5>	}
</span><span style=color:#eff1f5>}
</span></code></pre><p>Instead of creating a new FlxTimer object each time a bullet is recycled, the existing one is simply reset when needed.<p>Now back in the <code>Player.hx</code> class, we simply set and start the FlxTimer object for each bullet as they fire. The <code>start</code> method of an FlxTimer object <a href=http://api.haxeflixel.com/flixel/util/FlxTimer.html#start>takes three arguments</a>:<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span style=color:#8fa1b3>start</span><span>(Time:</span><span style=color:#ebcb8b>Float </span><span>= </span><span style=color:#d08770>1</span><span>, ?OnComplete:FlxTimerâ€‘></span><span style=color:#ebcb8b>Void</span><span>, Loops:</span><span style=color:#ebcb8b>Int </span><span>= </span><span style=color:#d08770>1</span><span>):FlxTimer
</span></code></pre><blockquote><p><strong>Time:Float</strong> How many seconds it takes for the timer to go off. If 0 then timer will fire OnComplete callback only once at the first call of update method (which means that Loops argument will be ignored).</blockquote><blockquote><p><strong>OnComplete:FlxTimer->Void</strong> Optional, triggered whenever the time runs out, once for each loop. Callback should be formed "onTimer(Timer:FlxTimer);"</blockquote><blockquote><p><strong>Loops:Int</strong> How many times the timer should go off. 0 means "looping forever".</blockquote><p>In the example below, I pass <code>2.0</code> for <code>Time</code>, an anonymous function for <code>OnComplete</code> that switches the bullets <code>exists</code> flag to <code>false</code>, and <code>1</code> for <code>Loops</code> so that the function only triggers once.<pre class=language-haxe data-lang=haxe style=color:#c0c5ce;background-color:#2b303b><code class=language-haxe data-lang=haxe><span style=color:#b48ead>if</span><span> (FlxG.</span><span style=color:#bf616a>keys</span><span>.</span><span style=color:#bf616a>justPressed</span><span>.</span><span style=color:#bf616a>Z</span><span>) {
</span><span>	</span><span style=color:#b48ead>var </span><span style=color:#bf616a>bullet</span><span>:Bullet = PlayState.</span><span style=color:#bf616a>bullets</span><span>.</span><span style=color:#8fa1b3>recycle</span><span>();
</span><span>	</span><span style=color:#bf616a>bullet</span><span>.</span><span style=color:#bf616a>timer</span><span>.</span><span style=color:#8fa1b3>start</span><span>(
</span><span>		</span><span style=color:#d08770>2.0</span><span>,
</span><span>		</span><span style=color:#b48ead>function </span><span>(</span><span style=color:#bf616a>Timer</span><span>:FlxTimer) {
</span><span>			</span><span style=color:#bf616a>bullet</span><span>.</span><span style=color:#bf616a>exists </span><span>= </span><span style=color:#d08770>false</span><span>;
</span><span>		},
</span><span>		</span><span style=color:#d08770>1
</span><span>	);
</span><span>}
</span></code></pre><p>So now, not only do you limit the amount of bullets that can be on the screen at once, but you can limit the duration for said bullets! It's a very neat and useful mechanic for balancing your game that can be applied to any pool of FlxBasic objects you may need, whether it be enemies, ammunition, or environmental objects.</p><img alt="asteroids animation" loading=lazy src=/img/blog/haxeflixel-bullet-timers/2.gif></article><footer class=mt2><small> <a href=#>return to top</a> </small></footer></div></main><script src=https://kevinfiol.com/js/dark-mode-switch.min.js></script>